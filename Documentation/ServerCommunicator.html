<br/><br/>/*<br/> NOTE: If you are a casual user, just focus on the Client and Server classes (i.e. ignore this one).<br/> <br/> This class is a singleton and is instantiated in main(). It allows the program's 3 threads (Client, Server, and TcpServer) to communicate. The only complexity here is the mutex locks.<br/> */<br/><br/>struct ServerCommunicator {<br/>public:<br/>&nbsp;&nbsp;&nbsp;&nbsp;bool getShouldServersContinue();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void setShouldServersContinue(bool newValue);<br/>&nbsp;&nbsp;&nbsp;&nbsp;void setLocalTcpPort(unsigned short newValue);<br/>&nbsp;&nbsp;&nbsp;&nbsp;unsigned short getLocalTcpPort();<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::vector<std::string> receiveTcpMessage();<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::vector<sf::TcpSocket*> getClients();<br/>&nbsp;&nbsp;&nbsp;&nbsp;void sendTcpMessageToServer(std::string message, std::string ip);<br/>&nbsp;&nbsp;&nbsp;&nbsp;void setClients(std::vector<sf::TcpSocket*> *vect);<br/>private:<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::mutex shouldServersContinue_lock;<br/>&nbsp;&nbsp;&nbsp;&nbsp;bool shouldServersContinue = true;<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::mutex tcpMessagesFromClients_lock;<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::queue<std::string> tcpMessagesFromClients;<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::queue<std::string> tcpIpsFromClients;<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::mutex clients_lock;<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::vector<sf::TcpSocket*> clients;<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::mutex localTcpPort_lock;<br/>&nbsp;&nbsp;&nbsp;&nbsp;unsigned short localTcpPort;<br/>};<br/><br/>