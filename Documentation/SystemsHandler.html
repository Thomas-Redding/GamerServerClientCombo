<br/><br/>/*<br/> Methods to be implemented:<br/> - entitiesToString()<br/> - entitiesFromString()<br/> - inputStateToString()<br/> - inputStateFromString()<br/> - clearInputState()<br/> */<br/><br/>class SystemsHandler {<br/>public:<br/>&nbsp;&nbsp;&nbsp;&nbsp;SystemsHandler(bool isServerSide);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>&nbsp;&nbsp;&nbsp;&nbsp; * Called at beginning of game<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param entities - struct to be edited to have starting conditions<br/>&nbsp;&nbsp;&nbsp;&nbsp; */<br/>&nbsp;&nbsp;&nbsp;&nbsp;void setupEntities(Entities *entities, std::string launchDetails);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>&nbsp;&nbsp;&nbsp;&nbsp; * Apply the given InputState-history to the world from startTime to endTime<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param entities - struct to be updated with history of InputStates<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param inputStates - queue of inputStates going backwards in time<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param startTime - time at which simulation should start<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param endtime - time at which simulation should end<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param avatarId - id of avatar for whom the inputStates describe<br/>&nbsp;&nbsp;&nbsp;&nbsp; */<br/>&nbsp;&nbsp;&nbsp;&nbsp;void update(Entities *entities, std::deque<InputState> *inputStates, long startTime, long endTime, int avatarId);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>&nbsp;&nbsp;&nbsp;&nbsp; * Lossless compression of the given entities into a string - indended for the given ip address (see entitiesFromString() ).<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param entities - Entities to be compressed<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param ip - IpAddress that the string is intended for<br/>&nbsp;&nbsp;&nbsp;&nbsp; */<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::string entitiesToString(Entities *entities, sf::IpAddress ip);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>&nbsp;&nbsp;&nbsp;&nbsp; * Lossless decompression from a string into an Entities object (see entitiesToString() )<br/>&nbsp;&nbsp;&nbsp;&nbsp; * The only exception is that the Map can be ignored<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param entities - entities that results should be written to<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param std::string - string to decompress from<br/>&nbsp;&nbsp;&nbsp;&nbsp; */<br/>&nbsp;&nbsp;&nbsp;&nbsp;void entitiesFromString(Entities *entities, std::string str);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>&nbsp;&nbsp;&nbsp;&nbsp; * Compress given InputState object into string<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param inputStates - InputState object to be compressed<br/>&nbsp;&nbsp;&nbsp;&nbsp; */<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::string inputStateToString(InputState *inputState);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>&nbsp;&nbsp;&nbsp;&nbsp; * Decompresses the given string into the given InputState object<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param inputState - InputState object to be decompressed<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param str - string to be decompressed<br/>&nbsp;&nbsp;&nbsp;&nbsp; */<br/>    void inputStateFromString(InputState *inputState, std::string str);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>&nbsp;&nbsp;&nbsp;&nbsp; * Fludily interpolate between two Entities. Note to developers: Do NOT focus on this. We may end up not needing it.<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param from - the Entities to return at t=0<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param to - the Entities to return at t=1<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param t - number between 0 and 1<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @return the constructed Entities between from and to<br/>&nbsp;&nbsp;&nbsp;&nbsp; */<br/>&nbsp;&nbsp;&nbsp;&nbsp;Entities interpolate(Entities *from, Entities *to, double t);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>private:<br/>&nbsp;&nbsp;&nbsp;&nbsp;bool isServer;<br/>&nbsp;&nbsp;&nbsp;&nbsp;PlayerSystem playerSystem;<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @inputStates - computes the deltaTime of each inputState<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @startTime - time the simulation starts<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @endTime - time the simulation ends<br/>&nbsp;&nbsp;&nbsp;&nbsp; */<br/>&nbsp;&nbsp;&nbsp;&nbsp;std::vector<float> inputStateWeights(std::deque<InputState> *inputStates, long startTime, long endTime);<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp;&nbsp;/*<br/>&nbsp;&nbsp;&nbsp;&nbsp; * computes the amount of overlap that two 1-dimensional lines have<br/>&nbsp;&nbsp;&nbsp;&nbsp; * assumes that a < b and c < d<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param a - starting point of first line<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param b - ending point of first line<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param c - starting point of second line<br/>&nbsp;&nbsp;&nbsp;&nbsp; * @param d - ending point of second line<br/>&nbsp;&nbsp;&nbsp;&nbsp; */<br/>&nbsp;&nbsp;&nbsp;&nbsp;long lineIntersect(long a, long b, long c, long d);<br/>};<br/><br/>